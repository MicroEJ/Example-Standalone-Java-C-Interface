/* 
 * Copyright 2012 IS2T. All rights reserved.
 * Modification and distribution is permitted under certain conditions.
 * IS2T PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */
/* 
 * AUTOGENERATED by COMP-ICETEA-ARMCC-ARM - 1.0.0 - DO NOT EDIT IT
 */
/**
 * GreenThread MicroJvm virtual machine API
 */
#ifndef _LLMJVM
#define _LLMJVM 
#include <intern\LLMJVM.h>
#include <stdint.h>
#ifdef __cplusplus
	extern "C" {
#endif
// --------------------------------------------------------------------------------
// -                                  Constants                                   -
// --------------------------------------------------------------------------------

/**
 * Exit code returned when the application ends normally (i.e. all the threads are terminated or <code>System.exit(exitCode)</code> has been called)
 */
#define LLMJVM_E_OK (0)

/**
 * Exit code returned when the SOAR used for the application is not compatible with the MicroJvm virtual machine.
 */
#define LLMJVM_E_SOAR_FILE_INCOMPATIBLE (-1)

/**
 * Exit code returned when the link specific configuration breaks MicroJvm virtual machine requirements.
 */
#define LLMJVM_E_BAD_LINK (-2)

/**
 * Exit code returned when the application ends because of the evaluation version limitations.
 */
#define LLMJVM_E_EVAL_LIMIT (-3)

/**
 * Exit code returned when the MicroJvm virtual machine is badly configured.
 */
#define LLMJVM_E_INV_OPTION (-4)

/**
 * Exit code returned when the Main thread can not be launched (for instance if thread stack can not be allocated).
 */
#define LLMJVM_E_MAIN_THREAD_ALLOC (-5)

/**
 * Exit code returned when the specified maximum number of threads exceeds MicroJvm virtual machine limits.
 */
#define LLMJVM_E_TOO_MANY_THREADS (-12)

/**
 * Exit code returned when the Java heap size is too large.
 */
#define LLMJVM_E_INV_HEAP_SIZE (-13)

/**
 * Exit code returned when the Java stacks memory is invalid. Check the stacks memory alignment or size.
 */
#define LLMJVM_E_INV_JAVA_STACK_MEM (-14)

/**
 * Exit code returned when the Java static fields memory is not large enough.
 */
#define LLMJVM_E_INV_JAVA_STATIC_MEM (-15)

/**
 * Exit code returned when the MicroJvm virtual machine cannot be restarted.
 */
#define LLMJVM_E_CANNOT_RESTART (-16)

/**
 * Exit code returned when the MicroJvm virtual machine is not in a valid state.
 */
#define LLMJVM_E_INV_STATE (-17)

/**
 * Exit code returned when the memory used for the Java heap or the immortal heap does not work properly. This may
 * be caused by an invalid external RAM configuration.
 */
#define LLMJVM_E_INV_HEAP_MEMORY (-18)

/**
 * Exit code returned when the memory used for the Java static fields does not work properly. This may
 * be caused by an invalid external RAM configuration.
 */
#define LLMJVM_E_INV_STATIC_MEMORY (-19)

/**
 * Error code returned when an error occurred.
 */
#define LLMJVM_E_ERROR (-1)

/**
 * Error code returned by {@link LLMJVM_suspendCurrentJavaThread} when suspend is not done.
 */
#define LLMJVM_E_INTERRUPTED (1)

// --------------------------------------------------------------------------------
// -                      Functions provided by the platform                      -
// --------------------------------------------------------------------------------

/**
 * <p>
 * Initializes the MicroJvm virtual machine. This function MUST be called once before
 * a call to {@link LLMJVM_start}.
 * </p>
 */
void LLMJVM_initialize(void);

/**
 * <p>
 * Starts the MicroJvm virtual machine and call the <code>main</code> method of  the Java
 * application with the given String arguments. This function returns when the Java
 * application ends.
 * </p>
 * <p>
 * The Java application ends when there is no more Java thread to run or when the Java method
 * <code>System.exit(int)</code> is called.
 * </p>
 * @param argc java main argument count
 * @param argv java main argument vector. An array of String (char**).
 * @return {@link LLMJVM_E_OK} when the MicroJvm virtual machine ends normally or a negative value
 * when an error occurred during startup.
 */
int32_t LLMJVM_start(int32_t argc, void* argv);

/**
 * <p>
 * Call this method after MicroJvm virtual machine execution to get the Java application exit code.
 * </p>
 * @return the value given to the <code>System.exit(exitCode)</code> or 0 if the Java application ends
 * without calling <code>System.exit(exitCode)</code>.
 */
int32_t LLMJVM_getExitCode(void);

/**
 * <p>
 * Prints the state of the MicroJvm virtual machine to the standard output stream.
 * For each Java thread, the Java stack trace, the name, the state and the priority are printed.
 * </p>
 */
void LLMJVM_dump(void);

/**
 * Returns the ID of the current Java thread.
 * This function should be called within the virtual machine
 * task.
 * Returns {@link LLMJVM_E_ERROR} if this function is not called within the
 * virtual machine task.
 */
int32_t LLMJVM_getCurrentJavaThreadID(void);

/**
 * Causes the current Java thread to pause its Java execution after the end
 * of the current native method. This function is not blocking.
 * The current Java thread will resume its execution after the reception
 * of an external event or after <code>timeout</code> milliseconds.
 * 
 * If a resume has been done on this thread before calling this function, the thread
 * is not paused.
 * 
 * The result of calling this method several times during the same native execution
 * is unpredictable.
 * 
 * @param timeout duration in milliseconds of the pause. If
 * <code>timeout</code> is zero, then time is not taken into consideration and the
 * thread simply waits until resumed.
 * 
 * @return {@link LLMJVM_E_ERROR} if the method has been called outside of the VM Task.
 * Returns {@link LLMJVM_E_OK} if the pause is effective (i.e. the thread will suspend its execution
 * at the end of the current native).
 * Returns {@link LLMJVM_E_INTERRUPTED} if a resume is pending; the current java thread will
 * not suspend its execution and pending resume is cleared.
 */
int32_t LLMJVM_suspendCurrentJavaThread(int64_t timeout);

/**
 * Resume the given Java thread if it is suspended.
 * If the Java thread is not paused, this resume stays pending.
 * Next call of SNI_suspendCurrentJavaThread() will return immediately.
 * 
 * Parameter <code>javaThreadID</code> is the ID of the Java thread to resume.
 * 
 * @return {@link LLMJVM_E_ERROR} if the given Java thread ID is invalid, otherwise returns {@link LLMJVM_E_OK}.
 */
int32_t LLMJVM_resumeJavaThread(int32_t javaThreadID);

#ifdef __cplusplus
	}
#endif
#endif
