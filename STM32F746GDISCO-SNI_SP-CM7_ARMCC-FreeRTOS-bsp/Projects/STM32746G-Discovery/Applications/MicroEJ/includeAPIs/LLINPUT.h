/* 
 * Copyright 2012-2013 IS2T. All rights reserved.
 * Modification and distribution is permitted under certain conditions.
 * IS2T PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */
/* 
 * AUTOGENERATED by COMP-ICETEA-ARMCC-ARM - 1.0.0 - DO NOT EDIT IT
 */
/**
 * The <code>LLInput</code> is an extension to the input stack.<br>
 * It provides some methods to create internal IS2T MicroUI events which
 * target IS2T MicroUI event generators implementations.
 */
#ifndef _LLINPUT
#define _LLINPUT 
#include <intern/LLINPUT.h>
#include <stdint.h>
#ifdef __cplusplus
	extern "C" {
#endif
// --------------------------------------------------------------------------------
// -                                  Constants                                   -
// --------------------------------------------------------------------------------

/**
 * The "escape" command constant.<br>
 * The value <code>0x0000</code> is assigned to <code>COMMAND_ESC</code>.
 */
#define LLINPUT_COMMAND_ESC (0)

/**
 * The "back" command constant.<br>
 * The value <code>0x0001</code> is assigned to <code>COMMAND_BACK</code>.
 */
#define LLINPUT_COMMAND_BACK (1)

/**
 * The "up" command constant.<br>
 * The value <code>0x0002</code> is assigned to <code>COMMAND_UP</code>.
 */
#define LLINPUT_COMMAND_UP (2)

/**
 * The "down" command constant.<br>
 * The value <code>0x0003</code> is assigned to <code>COMMAND_DOWN</code>.
 */
#define LLINPUT_COMMAND_DOWN (3)

/**
 * The "left" command constant.<br>
 * The value <code>0x0004</code> is assigned to <code>COMMAND_LEFT</code>.
 */
#define LLINPUT_COMMAND_LEFT (4)

/**
 * The "right" command constant.<br>
 * The value <code>0x0005</code> is assigned to <code>COMMAND_RIGHT</code>.
 */
#define LLINPUT_COMMAND_RIGHT (5)

/**
 * The "select" command constant.<br>
 * The value <code>0x0006</code> is assigned to <code>COMMAND_SELECT</code>.
 */
#define LLINPUT_COMMAND_SELECT (6)

/**
 * The "cancel" command constant.<br>
 * The value <code>0x0007</code> is assigned to <code>COMMAND_CANCEL</code>.
 */
#define LLINPUT_COMMAND_CANCEL (7)

/**
 * The "help" command constant.<br>
 * The value <code>0x0008</code> is assigned to <code>COMMAND_HELP</code>.
 */
#define LLINPUT_COMMAND_HELP (8)

/**
 * The "menu" command constant.<br>
 * The value <code>0x0009</code> is assigned to <code>COMMAND_MENU</code>.
 */
#define LLINPUT_COMMAND_MENU (9)

/**
 * The "exit" command constant.<br>
 * The value <code>0x000A</code> is assigned to <code>COMMAND_EXIT</code>.
 */
#define LLINPUT_COMMAND_EXIT (10)

/**
 * The "start" command constant.<br>
 * The value <code>0x000B</code> is assigned to <code>COMMAND_START</code>.
 */
#define LLINPUT_COMMAND_START (11)

/**
 * The "stop" command constant.<br>
 * The value <code>0x000C</code> is assigned to <code>COMMAND_STOP</code>.
 */
#define LLINPUT_COMMAND_STOP (12)

/**
 * The "pause" command constant.<br>
 * The value <code>0x000D</code> is assigned to <code>COMMAND_PAUSE</code>.
 */
#define LLINPUT_COMMAND_PAUSE (13)

/**
 * The "resume" command constant.<br>
 * The value <code>0x000E</code> is assigned to <code>COMMAND_RESUME</code>.
 */
#define LLINPUT_COMMAND_RESUME (14)

/**
 * The "copy" command constant.<br>
 * The value <code>0x000F</code> is assigned to <code>COMMAND_COPY</code>.
 */
#define LLINPUT_COMMAND_COPY (15)

/**
 * The "cut" command constant.<br>
 * The value <code>0x0010</code> is assigned to <code>COMMAND_CUT</code>.
 */
#define LLINPUT_COMMAND_CUT (16)

/**
 * The "paste" command constant.<br>
 * The value <code>0x0011</code> is assigned to <code>COMMAND_PASTE</code>.
 */
#define LLINPUT_COMMAND_PASTE (17)

/**
 * The "clockwise" command constant.<br>
 * The value <code>0x0012</code> is assigned to <code>COMMAND_CLOCKWISE</code>.
 */
#define LLINPUT_COMMAND_CLOCKWISE (18)

/**
 * The "anti-clockwise" command constant.<br>
 * The value <code>0x0013</code> is assigned to <code>COMMAND_ANTICLOCKWISE</code>.
 */
#define LLINPUT_COMMAND_ANTICLOCKWISE (19)

/**
 * The "previous" command constant.<br>
 * The value <code>0x0014</code> is assigned to <code>COMMAND_PREVIOUS</code>.
 */
#define LLINPUT_COMMAND_PREVIOUS (20)

/**
 * The "next" command constant.<br>
 * The value <code>0x0015</code> is assigned to <code>COMMAND_NEXT</code>.
 */
#define LLINPUT_COMMAND_NEXT (21)

/**
 * The "display" command constant.<br>
 * The value <code>0x0016</code> is assigned to <code>COMMAND_DISPLAY</code>.
 */
#define LLINPUT_COMMAND_DISPLAY (22)

// --------------------------------------------------------------------------------
// -                      Functions provided by the platform                      -
// --------------------------------------------------------------------------------

/**
 * Add an event to the generic event generator.<br>
 * The effect of this method is undefined when the given event generator (specified by
 * <code>eventGeneratorID</code>) is not an IS2T MicroUI <code>EventGenerator</code> 
 * event generator. <br>
 * The event will not be added if the internal events buffer is full.
 * @param eventGeneratorID the IS2T MicroUI <code>EventGenerator</code> event generator ID
 * @param event the 32-bit event
 * @return 1 if the event has been added
 */
uint8_t LLINPUT_sendEvent(int32_t eventGeneratorID, int32_t event);

/**
 * Add several events to the generic event generator.<br>
 * The effect of this method is undefined when the given event generator (specified by
 * <code>eventGeneratorID</code>) is not an IS2T MicroUI <code>EventGenerator</code> 
 * event generator. <br>
 * The events will not be added if the internal events buffer is or becomes full. If the
 * return value is not 1, no events have been added.
 * @param eventGeneratorID the IS2T MicroUI <code>EventGenerator</code> event generator ID
 * @param eventsArray the address of the 32-bit events array
 * @param length the number of events
 * @return 1 if all events have been added
 */
uint8_t LLINPUT_sendEvents(int32_t eventGeneratorID, int32_t* eventsArray, int32_t length);

/**
 * Add a command event to the event generator.<br>
 * The effect of this method is undefined when the given event generator (specified by
 * <code>commandsEventGeneratorID</code>) is not an IS2T MicroUI <code>Command</code> 
 * event generator (tag <code>&lt;command&gt;</code> in microui xml file). <br>
 * The event will not be added if the internal events buffer is full. <br>
 * @param commandsEventGeneratorID the IS2T MicroUI <code>Command</code> event generator ID
 * @param command the command to send, between 0 and 255
 * @return 1 if the event has been added
 */
uint8_t LLINPUT_sendCommandEvent(int32_t commandsEventGeneratorID, int32_t command);

/**
 * Add a PRESSED event to the event generator.<br>
 * The effect of this method is undefined when the given event generator (specified by
 * <code>buttonsEventGeneratorID</code>) is not an IS2T MicroUI <code>Buttons</code> 
 * event generator (tag <code>&lt;buttons&gt;</code> in microui xml file). <br>
 * The event will not be added if the internal events buffer is full. In this case the
 * caller should not send next RELEASED event (and potential REPEATED event(s)) to 
 * prevent unexpected behavior.
 * @param buttonsEventGeneratorID the IS2T MicroUI <code>Buttons</code> event generator ID
 * @param buttonId the button ID, between 0 and 255
 * @return 1 if the event has been added
 */
uint8_t LLINPUT_sendButtonPressedEvent(int32_t buttonsEventGeneratorID, int32_t buttonId);

/**
 * Add a RELEASED event to the event generator.<br>
 * The effect of this method is undefined when the given event generator (specified by
 * <code>buttonsEventGeneratorID</code>) is not an IS2T MicroUI <code>Buttons</code> 
 * event generator (tag <code>&lt;buttons&gt;</code> in microui xml file). <br>
 * The event will not be added if the internal events buffer is full. In this case the
 * caller should not send next PRESSED event to prevent unexpected behavior.
 * @param buttonsEventGeneratorID the IS2T MicroUI <code>Buttons</code> event generator ID
 * @param buttonId the button ID, between 0 and 255
 * @return 1 if the event has been added
 */
uint8_t LLINPUT_sendButtonReleasedEvent(int32_t buttonsEventGeneratorID, int32_t buttonId);

/**
 * Add a REPEATED event to the event generator.<br>
 * The effect of this method is undefined when the given event generator (specified by
 * <code>buttonsEventGeneratorID</code>) is not an IS2T MicroUI <code>Buttons</code> 
 * event generator (tag <code>&lt;buttons&gt;</code> in microui xml file). <br>
 * The event will not be added if the internal events buffer is full.
 * @param buttonsEventGeneratorID the IS2T MicroUI <code>Buttons</code> event generator ID
 * @param buttonId the button ID, between 0 and 255
 * @return 1 if the event has been added
 */
uint8_t LLINPUT_sendButtonRepeatedEvent(int32_t buttonsEventGeneratorID, int32_t buttonId);

/**
 * Add a PRESSED event to the event generator.<br>
 * The effect of this method is undefined when the given event generator (specified by
 * <code>pointerEventGeneratorID</code>) is not an IS2T MicroUI <code>Pointer</code> 
 * event generator (tag <code>&lt;pointer&gt;</code> in microui xml file). <br>
 * The event will not be added if the internal events buffer is full. In this case the
 * caller should not send next RELEASED event (and potential MOVE event(s)) to 
 * prevent unexpected behavior.
 * @param pointerEventGeneratorID the IS2T MicroUI <code>Pointer</code> event generator ID
 * @param buttonId the button ID, between 0 and 255
 * @param x the pointer X coordinate
 * @param y the pointer Y coordinate
 * @param absolute 1 when (x,y) coordinates are absolute, 0 when
 * there are relative to the previous pointer position
 * @return 1 if the event has been added
 */
uint8_t LLINPUT_sendPointerPressedEvent(int32_t pointerEventGeneratorID, int32_t buttonID, int32_t x, int32_t y, uint8_t absolute);

/**
 * Add a RELEASED event to the event generator.<br>
 * The effect of this method is undefined when the given event generator (specified by
 * <code>pointerEventGeneratorID</code>) is not an IS2T MicroUI <code>Pointer</code> 
 * event generator (tag <code>&lt;pointer&gt;</code> in microui xml file). <br>
 * The event will not be added if the internal events buffer is full. In this case the
 * caller should not send next PRESSED event to prevent unexpected behavior.
 * @param pointerEventGeneratorID the IS2T MicroUI <code>Pointer</code> event generator ID
 * @param buttonId the button ID, between 0 and 255
 * @return 1 if the event has been added
 */
uint8_t LLINPUT_sendPointerReleasedEvent(int32_t pointerEventGeneratorID, int32_t buttonID);

/**
 * Add a MOVE event to the event generator.<br>
 * The effect of this method is undefined when the given event generator (specified by
 * <code>pointerEventGeneratorID</code>) is not an IS2T MicroUI <code>Pointer</code> 
 * event generator (tag <code>&lt;pointer&gt;</code> in microui xml file). <br>
 * The event will not be added if the internal events buffer is full.
 * @param pointerEventGeneratorID the IS2T MicroUI <code>Pointer</code> event generator ID
 * @param x the pointer X coordinate
 * @param y the pointer Y coordinate
 * @param absolute 1 when (x,y) coordinates are absolute, 0 when
 * there are relative to the previous pointer position
 * @return 1 if the event has been added
 */
uint8_t LLINPUT_sendPointerMovedEvent(int32_t pointerEventGeneratorID, int32_t x, int32_t y, uint8_t abs);

/**
 * Add a PRESSED event to the event generator.<br>
 * The effect of this method is undefined when the given event generator (specified by
 * <code>touchEventGeneratorID</code>) is not an IS2T MicroUI <code>Touch</code> 
 * event generator (tag <code>&lt;touch&gt;</code> in microui xml file). <br>
 * The event will not be added if the internal events buffer is full. In this case the
 * caller should not send next RELEASED event (and potential MOVE event(s)) to 
 * prevent unexpected behavior.
 * @param touchEventGeneratorID the IS2T MicroUI <code>Touch</code> event generator ID
 * @param x the pointer X coordinate
 * @param y the pointer Y coordinate
 * @return 1 if the event has been added
 */
uint8_t LLINPUT_sendTouchPressedEvent(int32_t touchEventGeneratorID, int32_t x, int32_t y);

/**
 * Add a RELEASED event to the event generator.<br>
 * The effect of this method is undefined when the given event generator (specified by
 * <code>touchEventGeneratorID</code>) is not an IS2T MicroUI <code>Pointer</code> 
 * event generator (tag <code>&lt;touch&gt;</code> in microui xml file). <br>
 * The event will not be added if the internal events buffer is full. In this case the
 * caller should not send next PRESSED event to prevent unexpected behavior.
 * @param touchEventGeneratorID the IS2T MicroUI <code>Touch</code> event generator ID
 * @return 1 if the event has been added
 */
uint8_t LLINPUT_sendTouchReleasedEvent(int32_t touchEventGeneratorID);

/**
 * Add a MOVE event to the event generator.<br>
 * The effect of this method is undefined when the given event generator (specified by
 * <code>touchEventGeneratorID</code>) is not an IS2T MicroUI <code>Touch</code> 
 * event generator (tag <code>&lt;touch&gt;</code> in microui xml file). <br>
 * The event will not be added if the internal events buffer is full.
 * @param touchEventGeneratorID the IS2T MicroUI <code>Pointer</code> event generator ID
 * @param x the pointer X coordinate
 * @param y the pointer Y coordinate
 * @return 1 if the event has been added
 */
uint8_t LLINPUT_sendTouchMovedEvent(int32_t touchEventGeneratorID, int32_t x, int32_t y);

/**
 * Add a STATE event to the event generator.<br>
 * The effect of this method is undefined when the given event generator (specified by
 * <code>statesEventGeneratorID</code>) is not an IS2T MicroUI <code>States</code> 
 * event generator (tag <code>&lt;states&gt;</code> in microui xml file). <br>
 * The event will not be added if the internal events buffer is full.
 * @param statesEventGeneratorID the IS2T MicroUI <code>States</code> event generator ID
 * @param stateID the state machine identifier, between 0 and 255
 * @param stateValue the new state if the state machine, between 0 and 255
 * @return 1 if the event has been added
 */
uint8_t LLINPUT_sendStateEvent(int32_t statesEventGeneratorID, int32_t stateID, int32_t stateValue);

/**
 * Returns the maximum usage of the native events buffer. This can be useful for
 * tuning the size of the buffer.
 * @return the maximum usage of the native events buffer.
 */
int32_t LLINPUT_getMaxEventsBufferUsage(void);

#ifdef __cplusplus
	}
#endif
#endif
